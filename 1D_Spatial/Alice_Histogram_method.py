"""
Гистограммный метод — это визуальный и вычислительный подход
к разделению данных на два класса (кластера) на основе формы гистограммы их распределения.

В чём идея
Если в данных есть два отчётливых «горба» (мода), это часто означает,
что выборка состоит из двух разных групп.
Например:
здоровые и больные пациенты по уровню маркера;
фон и объект на изображении по яркости пикселей;
два типа клиентов по сумме покупок.

Задача метода — найти порог (границу) между этими группами,
т. е. такое значение T, чтобы:
все xi < T отнести к первой группе;
все xi ≥ T — ко второй.

Как выбрать порог
Визуально — посмотреть на гистограмму и найти «долину» между двумя пиками.
Автоматически — использовать алгоритмы:
- поиск минимума между пиками;
- метод Оцу (Otsu’s method) — оптимально разделяет гистограмму на 2 класса, минимизируя внутриклассовую дисперсию;
- порог на уровне 50 % от высоты меньшего пика.

Что делает код
1/ Генерирует данные — два нормальных распределения с разными средними (20 и 40).
2/ Строит гистограмму — видно два пика.
3/ Находит пики с помощью scipy.signal.find_peaks.
4/ Ищет минимум между пиками — это и есть порог T.
5/ Рисует порог на графике (красная пунктирная линия).
6/ Делит данные на две группы по T и выводит статистику.

Важные замечания
- Чувствительность к числу бинов. Попробуйте разные bins в plt.hist(), чтобы результат был устойчивым.
- Метод Оцу (в OpenCV/skimage) часто даёт более точный порог для изображений.
- Если пики сливаются, порог может быть неточным — тогда нужны другие методы (EM‑алгоритм, GMM).

Итог: гистограммный метод прост, нагляден и работает, когда данные явно разделены на два кластера.
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# 1. Генерируем данные: два нормальных распределения
np.random.seed(42)
group1 = np.random.normal(loc=20, scale=5, size=300)   # первый кластер
group2 = np.random.normal(loc=40, scale=7, size=400)   # второй кластер
data = np.concatenate([group1, group2])                # объединённая выборка

# 2. Строим гистограмму
plt.figure(figsize=(10, 6))
counts, bins, patches = plt.hist(data, bins=40, color='skyblue', alpha=0.7, edgecolor='black')
plt.xlabel('Значение признака')
plt.ylabel('Частота')
plt.title('Гистограмма данных с двумя пиками')
plt.grid(True, alpha=0.3)
plt.show()

# 3. Находим пики гистограммы (аппроксимация)
from scipy.signal import find_peaks
peaks, _ = find_peaks(counts, height=np.max(counts)*0.3)  # пики выше 30% от макс.
peak_bins = bins[peaks]  # значения на оси X, где пики

print(f"Пики гистограммы найдены при X ≈ {peak_bins[0]:.1f} и {peak_bins[1]:.1f}")

# 4. Ищем минимум между пиками (порог)
left_peak_idx = peaks[0]
right_peak_idx = peaks[1]

# Область между пиками
between_peaks = counts[left_peak_idx+1 : right_peak_idx]
min_idx_between = np.argmin(between_peaks) + left_peak_idx + 1

threshold = bins[min_idx_between]
print(f"Порог разделения (минимум между пиками): T = {threshold:.2f}")


# 5. Визуализируем порог
plt.figure(figsize=(10, 6))
plt.hist(data, bins=40, color='skyblue', alpha=0.7, edgecolor='black')
plt.axvline(x=threshold, color='red', linestyle='--', linewidth=2, label=f'Порог T = {threshold:.2f}')
plt.xlabel('Значение признака')
plt.ylabel('Частота')
plt.title('Гистограмма с найденным порогом')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# 6. Разделяем данные по порогу
group_a = data[data < threshold]
group_b = data[data >= threshold]

print(f"\nРазделение данных:")
print(f"Группа A (x < T): {len(group_a)} элементов, среднее = {np.mean(group_a):.2f}")
print(f"Группа B (x ≥ T): {len(group_b)} элементов, среднее = {np.mean(group_b):.2f}")
